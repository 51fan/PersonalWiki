## A successful Git branching model - 一个成功的Git建立分支模型 [**Back**](./../translation.md)

> * 原文链接 : [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/)
* 原文作者 : [Vincent Driessen](http://nvie.com/about/)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者: 暂无
* 状态 :  翻译中

&#160; &#160; &#160; &#160;在这篇博文中，我将展示大概一年前我的一些项目（包括工作或者私人的项目）中，使用的建立分支开发模型。结果发现，这个模型的确是非常成功的一个模型。因此，我想把其记录成文档，但直到现在才腾出了时间去完成。在这篇文章中，我并不会探讨项目的细节。我们将要讨论的将是建立分支的策略以及代码版本的控制。

<img src="./git-model@2x.png">

&#160; &#160; &#160; &#160;该模型将会使用 [Git](http://git-scm.com/) 作为工具，去对我们的源代码进行版本标记。（顺便一说的是，如果你对 Git 有兴趣，我们公司 [GitPrime](http://gitprime.com/) 会为你提供一些令人惊叹的实时数据分析工具，用于软件工程性能的分析）

### 为什么选择 Git？

&#160; &#160; &#160; &#160;因为我们通过集中几个源代码管理系统，就 Git 的优点以及缺点方面进行了彻底地讨论，详细可以[参考](http://whygitisbetterthanx.com/)我们的[网站](http://git.or.cz/gitwiki/GitSvnComparsion)。在这个问题上的斗争，可以说是非常的激烈。当今，作为一位开发人员，相比使用其他的工具，我更倾向于使用 Git。这是因为 Git 真正改变了开发人员对合并分支（merging）以及建立分支（branching）的思考。从经典的并发版本控制系统（CVS）/子系统（Subversion）世界过来的我，总是认为合并分支/建立分支是何等的吓人（“请小心合并分支时产生的冲突，因为它是会随时咬你的”）。而且，这又是你等会将需要做的唯一事情，而这事情又是你每次都需要做的。

&#160; &#160; &#160; &#160;然而，自从有了 Git 后，这一切的动作都将变得如此简单和便捷。而且，这一动作也将成为你日常工作流中的重要环节之一。举个例子来说，在并发版本控制系统/子系统的[相关书籍](http://svnbook.red-bean.com/)中，建立分支和合并分支都只是在最后的章节作出首次的提及（对于需要高级操作的用户有用），然而在[每一个讲述 Git 的书籍](http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git)中，这将会在第三个章节就会被提及到（作为基础部分）。

&#160; &#160; &#160; &#160;作为简洁和自然重复的结果，建立分支与合并分支不再是一种可怕的存在。而版本控制工具则应该去协助建立分支/合并分支的操作。

&#160; &#160; &#160; &#160;讲述完工具，我们来谈谈相关的开发模型。这里我将展示的模型基本上仅是每一个团队成员都需要遵行的一组过程。这是为了能够达到一个被管理的软件，其开发的过程。

### 集中却分散

&#160; &#160; &#160; &#160;那些能配置使用且能有效使用这个建立分支开发模型的仓库，必须是那些有着一个中心化且“真实的”仓库。注意的是，该仓库仅仅是中心的那一个（然而既然 Git 是一个分布式版本控制系统（DVCS），那么从技术层面上来说，就不应该有这样一个东西去承担中心仓库的角色）。下面，我们会把该仓库称作原始仓库（origin），而且对于所以的 Git 用户来说，这样的命名最熟悉不过。

<img src="./centr-decentr@2x.png">

&#160; &#160; &#160; &#160;每一个开发人员都需要从原始仓库下拉以及上推代码。但是，除了这种中心化下拉-上推关系之外，每一个开发人员为了形成一个子团队，都可能需要从其他的同伴下来更新的代码。举个例子来说就是，如果两个或多个的开发者同时在一个大的新项目上协同工作时，在过早提交代码到原始仓库之前，从伙伴下拉更新的代码就会显得非常有用。上图所示，这里有着一个由 Alice 和 Bob、Alice 和 David 以及 Clair 和 Davi 三种关系组成的子团队。

&#160; &#160; &#160; &#160;技术上来说，这就意味着比起 Alice 去定义一个远程的 Git 项目并命名成 bob，然后指向 Bob 的仓库会来说，也没有太大的意义，反之亦是。

### 主分支

<img src="./main-branches@2x.png">

&#160; &#160; &#160; &#160;这开发模型的核心部分，其形成主要是受到上图所存在的模型所启发。中心仓库持有两条生命期无限期的分支：

- 主分支（**master**）
- 开发分支（**develop**）

&#160; &#160; &#160; &#160;在原始仓库中，每一个 Git 用户对 **master** 分支应该都稍有了解。而与 **master** 分支平行的有一条分支，叫作 **develop** 分支。

&#160; &#160; &#160; &#160;我们把 **origin/master** 作为一条主分支，而该主分支上的源代码，其头指针 **HEAD** 总是指向一个生产就绪（production-ready）的状态。

&#160; &#160; &#160; &#160;而我们把 **origin/develop** 作为另一条主分支。该分支上的代码，其头指针则总是指向最新一次交付的开发更新版本。该版本用于下一个次版本的发行。有些人会称这条分支为“集成分支（integration branch）”。那是因为，这条分支也是每一晚代码构件的来源地方。

<a href="http://aleen42.github.io/" target="_blank" ><img src="./../../pic/tail.gif"></a>
