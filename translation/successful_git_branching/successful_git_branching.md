## A successful Git branching model - 一个成功的Git建立分支模型 [**Back**](./../translation.md)

> * 原文链接 : [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/)
* 原文作者 : [Vincent Driessen](http://nvie.com/about/)
* 译者 : [aleen42](https://github.com/aleen42) 
* 校对者: 暂无
* 状态 :  翻译中

&#160; &#160; &#160; &#160;在这篇博文中，我将展示大概一年前我的一些项目（包括工作或者私人的项目）中，使用的建立分支开发模型。结果发现，这个模型的确是非常成功的一个模型。因此，我想把其记录成文档，但直到现在才腾出了时间去完成。在这篇文章中，我并不会探讨项目的细节。我们将要讨论的将是建立分支的策略以及代码版本的控制。

<img src="./git-model@2x.png">

&#160; &#160; &#160; &#160;该模型将会使用 [Git](http://git-scm.com/) 作为工具，去对我们的源代码进行版本标记。（顺便一说的是，如果你对 Git 有兴趣，我们公司 [GitPrime](http://gitprime.com/) 会为你提供一些令人惊叹的实时数据分析工具，用于软件工程性能的分析）

### 为什么选择 Git？

&#160; &#160; &#160; &#160;因为我们通过集中几个源代码管理系统，就 Git 的优点以及缺点方面进行了彻底地讨论，详细可以[参考](http://whygitisbetterthanx.com/)我们的[网站](http://git.or.cz/gitwiki/GitSvnComparsion)。在这个问题上的斗争，可以说是非常的激烈。当今，作为一位开发人员，相比使用其他的工具，我更倾向于使用 Git。这是因为 Git 真正改变了开发人员对合并分支（merging）以及建立分支（branching）的思考。从经典的并发版本控制系统（CVS）/子系统（Subversion）世界过来的我，总是认为合并分支/建立分支是何等的吓人（“请小心合并分支时产生的冲突，因为它是会随时咬你的”）。而且，这又是你等会将需要做的唯一事情，而这事情又是你每次都需要做的。

&#160; &#160; &#160; &#160;然而，自从有了 Git 后，这一切的动作都将变得如此简单和便捷。而且，这一动作也将成为你日常工作流中的重要环节之一。举个例子来说，在并发版本控制系统/子系统的[相关书籍](http://svnbook.red-bean.com/)中，建立分支和合并分支都只是在最后的章节作出首次的提及（对于需要高级操作的用户有用），然而在[每一个讲述 Git 的书籍](http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git)中，这将会在第三个章节就会被提及到（作为基础部分）。

&#160; &#160; &#160; &#160;作为简洁和自然重复的结果，建立分支与合并分支不再是一种可怕的存在。而版本控制工具则应该去协助建立分支/合并分支的操作。

&#160; &#160; &#160; &#160;讲述完工具，我们来谈谈相关的开发模型。这里我将展示的模型基本上仅是每一个团队成员都需要遵行的一组过程。这是为了能够达到一个被管理的软件，其开发的过程。

### 集中却分散

&#160; &#160; &#160; &#160;那些能配置使用且能有效使用这个建立分支开发模型的仓库，必须是那些有着一个中心化且“真实的”仓库。注意的是，该仓库仅仅是中心的那一个（然而既然 Git 是一个分布式版本控制系统（DVCS），那么从技术层面上来说，就不应该有这样一个东西去承担中心仓库的角色）。下面，我们会把该仓库称作原始仓库（origin），而且对于所以的 Git 用户来说，这样的命名最熟悉不过。

<img src="./centr-decentr@2x.png">

&#160; &#160; &#160; &#160;每一个开发人员都需要从原始仓库下拉以及上推代码。但是，除了这种中心化下拉-上推关系之外，每一个开发人员为了形成一个子团队，都可能需要从其他的同伴下来更新的代码。举个例子来说就是，如果两个或多个的开发者同时在一个大的新项目上协同工作时，在过早提交代码到原始仓库之前，从伙伴下拉更新的代码就会显得非常有用。上图所示，这里有着一个由 Alice 和 Bob、Alice 和 David 以及 Clair 和 Davi 三种关系组成的子团队。

&#160; &#160; &#160; &#160;技术上来说，这就意味着比起 Alice 去定义一个远程的 Git 项目并命名成 bob，然后指向 Bob 的仓库会来说，也没有太大的意义，反之亦是。

### 主分支

<img src="./main-branches@2x.png">

&#160; &#160; &#160; &#160;这开发模型的核心部分，其形成主要是受到上图所存在的模型所启发。中心仓库持有两条生命期无限期的分支：

- 主分支（**master**）
- 开发分支（**develop**）

&#160; &#160; &#160; &#160;在原始仓库中，每一个 Git 用户对 **master** 分支应该都稍有了解。而与 **master** 分支平行的有一条分支，叫作 **develop** 分支。

&#160; &#160; &#160; &#160;我们把 **origin/master** 作为一条主分支，而该主分支上的源代码，其头指针 **HEAD** 总是指向一个生产就绪（production-ready）的状态。

&#160; &#160; &#160; &#160;而我们把 **origin/develop** 作为另一条主分支。该分支上的代码，其头指针则总是指向最新一次交付的开发更新版本。该版本用于下一个次版本的发行。有些人会称这条分支为“集成分支（integration branch）”。那是因为，这条分支也是每一晚代码自动构建的来源地方。

&#160; &#160; &#160; &#160;当在 **develop** 分支上的源代码到达了一个相对稳定的点并能发行的时候，所有该分支上的修动部分都应该被合并回 **master** 分支上，并用一个新的发行号来标记它。至于具体怎么做，我们接下来会更加深入去讨论。

&#160; &#160; &#160; &#160;所以，每一次当修动部分被合并回 **master** 分支时，确实这就意味着一个新的产品已经被发行出来。在这定义上，我们更倾向于严格要求。因为只有这样，在理论上我们每一次提交代码到 **master** 分支时，才能使用 Git 的钩子脚本（hook script）去自动构建或回滚我们的软件，并部署于产品服务器。

### 支承分支

&#160; &#160; &#160; &#160;在 **master** 和 **develop** 分支下，我们的开发模型使用了不同的支承分支去帮助团队成员之间的平行开发、缓解特征的追踪、为产品发行作准备以及协助快速解决“现场”产品所带来的问题。不同于两个主要分支的是，这些支承分支总是有一个有限的生命周期。这是因为，它们会被最终移除。

&#160; &#160; &#160; &#160;我们或许会使用不同类型的支承分支有：

- 特征分支（Feature branches）
- 发行分支（Release branches）
- 热补丁分支（Hotfix branches）

&#160; &#160; &#160; &#160;每一种分支，都必须有其特定的目的，并绑定有其严格的要求。这是因为随着时间推移，某些分支可能会成为这些分支的原始分支以及某些分支可能会成为这些分支的合并对象。若干分钟后，我们会探讨它们的区别。

&#160; &#160; &#160; &#160;其实，这些分支比起一些科学领域来说，一点都不“特殊”。它们的分类都是根据我们怎么使用它来区分。当然,它们都是相当旧式的 Git 分支。

#### Feature 分支

<img src="./fb@2x.png">

&#160; &#160; &#160; &#160;或许是从以下分支分离出来：

- **develop**

&#160; &#160; &#160; &#160;或许会合并到以下分支：

- **develop**

&#160; &#160; &#160; &#160;**Feature** 分支（有时称作话题分支（topic branches））是用于对未来即将要来或者是一个不一样的发行版开发新的功能。我们在开发新功能的时候，并不知道该新功能将来会在哪个版本发行。因此，**Feature** 分支的本质就在于，只要该新功能仍处于开发阶段，那么该分支就会一直存在。然而，最终当功能开发完成时，该分支还是会被合并到 **develop** 分支（确实要添加这新功能到该发行版的时候）或者被抛弃（当然这是在不满意的情况下发生）。

&#160; &#160; &#160; &#160;一般地，**Feature** 分支是只存在于开发者的仓库，而并不会存在于原始仓库。

###### 创建一个 Feature 分支

&#160; &#160; &#160; &#160;当开始开发一个新功能时，从 **develop** 分支分离出来。

```bash
git checkout -b myfeature develop
# Switched to a new branch 'myfeature'
```

###### 合并一个已经完成的 Feature 分支到 develop 分支

&#160; &#160; &#160; &#160;完成了的功能需要合并到 **develop** 分支，以确切把其添加到下一个要发行的版本中。

```bash
git checkout develop
# Switched to branch 'develop'

git merge --no-ff myfeature
# Updating ea1b82a..05e9557
# (Summary of changes)

git branch -d myfeature
# Deleted branch myfeature (was 05e9557).

git push origin develop
```

&#160; &#160; &#160; &#160;标志位 --no-ff 表示每次合并分支时总要去生成一个新的提交对象，即使该合并表现为一个快进（fast-forward）状态。通过设置其就可以避免丢失一些信息，包括一个 Feature 分支的历史存在记录。而且还可以整合所有的关于这次功能添加的提交记录。这个我们可以通过下图来对比一下：

<img src="./merge-without-ff@2x.png">

在后一种情况下，我们可能可以通过翻看到 Git 的历史纪录，知道哪些提交对象是共同用于完成一个功能的 —— 但你需要手动去读取所有的日志消息。况且，倘若需要回滚整个功能（例如一组的提交），那么在后一种情况将是一个令人头疼的事情，而当我们使用 --no-ff 标志就可以轻松解决这个问题。

&#160; &#160; &#160; &#160;没错，这种情况下会新增加一些（可能空的）提交对象。然而，这是一种利大于弊的做法。

#### Release 分支

&#160; &#160; &#160; &#160;或许是从以下分支分离出来：

- **develop**

&#160; &#160; &#160; &#160;或许会合并到以下分支：

- **develop** 和 **master**

&#160; &#160; &#160; &#160;该分支的命名规范：

- release-*

<a href="http://aleen42.github.io/" target="_blank" ><img src="./../../pic/tail.gif"></a>
